

import { IFakerService } from "../IFakerService";

export class SnowfakeryFakerService implements IFakerService {

    openingRecipeSyntax:string = "${{";
    closingRecipeSyntax:string = "}}";

    generateTabs(tabCount: number):string {
        const spacesPerTab = 4;
        return ' '.repeat(spacesPerTab * tabCount);
    }

    getMapSalesforceFieldToFakerValue():Record<string, string> {

        const salesforceFieldToSnowfakeryMap: Record<string, string> = {
            'text': '${{fake.text(max_nb_chars=50)}}',
            'textarea': '${{fake.paragraph()}}',
            'longtextarea': '${{fake.text(max_nb_chars=1000)}}',
            'richtextarea': '${{fake.text(max_nb_chars=1000)}}',
            'email': '${{fake.email()}}',
            'phone': '${{fake.phone_number()}}',
            'url': '${{fake.url()}}',
            'number': '${{fake.random_int(min=0, max=999999)}}',
            'currency': '${{fake.pydecimal(left_digits=6, right_digits=2, positive=True)}}',
            'percent': '${{fake.pydecimal(left_digits=2, right_digits=2, positive=True)}}',
            'date': '${{date(fake.date_between(start_date="-1y", end_date="today"))}}',
            'datetime': '${{fake.date_time_between(start_date="-1y", end_date="now")}}',
            'time': '${{fake.time()}}',
            'picklist': 'GENERATED BY FIELD XML MARKUP',
            'multiselectpicklist': 'GENERATED BY FIELD XML MARKUP',
            'checkbox': '${{fake.boolean()}}',
            'lookup': '"TODO -- REFERENCE ID REQUIRED"',
            'masterdetail': '"TODO -- REFERENCE ID REQUIRED"',
            'formula': 'Formula fields are calculated, not generated',
            'location': '"SEE ONE PAGER - https://gist.github.com/jdschleicher/4abfd188a933598833285ee76e560445"'
        };
    
        return salesforceFieldToSnowfakeryMap;

    }

    buildMultiSelectPicklistRecipeValueByXMLFieldDetail(availablePicklistChoices: string[],
                                                            recordTypeToPicklistFieldsToAvailablePicklistValuesMap: Record<string, Record<string, string[]>>,
                                                            associatedFieldApiName
                                                        ): string {

        const commaJoinedPicklistChoices = availablePicklistChoices.join("', '");
        let fakeMultiSelectRecipeValue = `${this.openingRecipeSyntax} (';').join((fake.random_sample(elements=('${commaJoinedPicklistChoices}')))) ${this.closingRecipeSyntax}`;
        
        const recordTypeBasedRecipeValues = this.buildRecordTypeBasedMultipicklistRecipeValue(recordTypeToPicklistFieldsToAvailablePicklistValuesMap, associatedFieldApiName);
        if ( recordTypeBasedRecipeValues) {
            fakeMultiSelectRecipeValue += `\n${recordTypeBasedRecipeValues}`;
        }
        
        return fakeMultiSelectRecipeValue;

    }

    buildDependentPicklistRecipeFakerValue(
                        controllingValueToPicklistOptions: Record<string, string[]>, 
                        recordTypeToPicklistFieldsToAvailablePicklistValuesMap: Record<string, Record<string, string[]>>,
                        controllingField: string,
                        fieldApiName: string
                    ): string {
    
        let allDependentPicklistChoiceRecipe:string;

        const newLineBreak = `\n`;

        for ( const controllingValueKey in controllingValueToPicklistOptions ) {
            
            let randomChoicesBreakdown:string;

            let picklistValuesAvailableForChoice = controllingValueToPicklistOptions[controllingValueKey];
            // get initial list of all available picklist values before record type sections
            picklistValuesAvailableForChoice.forEach( value => {

                if (randomChoicesBreakdown) {
                    randomChoicesBreakdown += `${newLineBreak}${this.generateTabs(5)}- ${value}`;
                } else {
                    randomChoicesBreakdown = `- ${value}`;
                }

            });   

            const allRecordTypeChoicesBreakdown = this.updateDependentPicklistRecipeFakerValueByRecordTypeSections( 
                                            recordTypeToPicklistFieldsToAvailablePicklistValuesMap, 
                                            fieldApiName, 
                                            controllingField,
                                            controllingValueKey
                                        );

            if (allRecordTypeChoicesBreakdown) {
                randomChoicesBreakdown += allRecordTypeChoicesBreakdown;
            }

            let dependentPicklistRandomChoiceRecipe = 
`${this.generateTabs(2)}- choice:
${this.generateTabs(3)}when: ${this.openingRecipeSyntax} ${controllingField} == '${controllingValueKey}' }}
${this.generateTabs(3)}pick:
${this.generateTabs(4)}random_choice:
${this.generateTabs(5)}${randomChoicesBreakdown}`;

            if (!(allDependentPicklistChoiceRecipe)) {
                allDependentPicklistChoiceRecipe = dependentPicklistRandomChoiceRecipe;
            } else {
                const lineBreakRandomChoiceRecipe = `\n${dependentPicklistRandomChoiceRecipe}`;
                allDependentPicklistChoiceRecipe += lineBreakRandomChoiceRecipe;
            }

        }

        let fakeDependentPicklistRecipeValue = "";

        if (fakeDependentPicklistRecipeValue) {
            fakeDependentPicklistRecipeValue += `\n${this.generateTabs(2)}${allDependentPicklistChoiceRecipe}`;
        } else {
            fakeDependentPicklistRecipeValue = `\n${this.generateTabs(1.5)}if:`;
            fakeDependentPicklistRecipeValue += `\n${allDependentPicklistChoiceRecipe}`;
        }

        return fakeDependentPicklistRecipeValue;

    }

    buildPicklistRecipeValueByXMLFieldDetail(availablePicklistChoices: string[], 
                                                recordTypeToPicklistFieldsToAvailablePicklistValuesMap: Record<string, Record<string, string[]>>,
                                                associatedFieldApiName): string {

        const commaJoinedPicklistChoices = availablePicklistChoices.join("', '");
        let fakeRecipeValue = `${this.openingRecipeSyntax} random_choice('${commaJoinedPicklistChoices}') ${this.closingRecipeSyntax}`;

        const recordTypeBasedRecipeValues = this.buildRecordTypeBasedPicklistRecipeValue(recordTypeToPicklistFieldsToAvailablePicklistValuesMap, associatedFieldApiName);
        if ( recordTypeBasedRecipeValues) {
            fakeRecipeValue += `\n${recordTypeBasedRecipeValues}`;
        }

        return fakeRecipeValue;

    }

    updateDependentPicklistRecipeFakerValueByRecordTypeSections(recordTypeNameByRecordTypeNameToXMLMarkup: Record<string, any>,
                                                                dependentFieldApiName: string,
                                                                controllingFieldApiName: string,
                                                                controllingValue: string
                                                            ): string {

        const newLineBreak: string = `\n`;
        let allRecordTypeChoicesBreakdown:string = '';    
                                                        
        Object.entries(recordTypeNameByRecordTypeNameToXMLMarkup).forEach(([recordTypeApiNameKey, recordTypeDetail]) => {
                
            const availableRecordTypePicklistValuesForControllingField = recordTypeNameByRecordTypeNameToXMLMarkup[recordTypeApiNameKey][controllingFieldApiName];

            const noPicklistValuesForRecordTypeVerbiage = `${newLineBreak}${this.generateTabs(5)}### TODO: -- RecordType Options -- ${recordTypeApiNameKey} -- "${controllingValue}" is not an available value for ${controllingFieldApiName} for record type ${recordTypeApiNameKey}`;

            if ( !availableRecordTypePicklistValuesForControllingField.includes(controllingValue) ) {
                // picklist value not available for record type so no dependent picklist values to process
                allRecordTypeChoicesBreakdown += noPicklistValuesForRecordTypeVerbiage;
            } else {

                let recordTypeChoicesBreakdown:string;

                const picklistValuesForDependentField = recordTypeNameByRecordTypeNameToXMLMarkup[recordTypeApiNameKey][dependentFieldApiName];
                picklistValuesForDependentField.forEach( recordTypeAvailablePicklistValue => {
    
                    if (recordTypeChoicesBreakdown) {
                        recordTypeChoicesBreakdown += `${newLineBreak}${this.generateTabs(5)}- ${recordTypeAvailablePicklistValue}`;
                    } else {
                        const recordTypeTodoVerbiage = `### TODO: -- RecordType Options -- ${recordTypeApiNameKey} -- SELECT THIS SECTION OF OPTIONS IF USING RECORD TYPE -- ${recordTypeApiNameKey}`;
                        recordTypeChoicesBreakdown = `${newLineBreak}${this.generateTabs(5)}${recordTypeTodoVerbiage}${newLineBreak}${this.generateTabs(5)}- ${recordTypeAvailablePicklistValue}`;                                
                    }
    
                });
    
                allRecordTypeChoicesBreakdown += recordTypeChoicesBreakdown;
            }

        });

        return allRecordTypeChoicesBreakdown;

    }

    buildRecordTypeBasedPicklistRecipeValue(recordTypeToPicklistFieldsToAvailablePicklistValuesMap: Record<string, Record<string, string[]>>,
                                            associatedFieldApiName: string) {

        let allRecordTypeBasedPicklistOptions:string = '';
        const newLineBreak = `\n`;

        Object.entries(recordTypeToPicklistFieldsToAvailablePicklistValuesMap).forEach(([recordTypeApiNameKey, recordTypeDetail]) => {

            const availableRecordTypePicklistValuesForField = recordTypeToPicklistFieldsToAvailablePicklistValuesMap[recordTypeApiNameKey][associatedFieldApiName];
            if ( availableRecordTypePicklistValuesForField ) {

                const commaJoinedPicklistChoices = availableRecordTypePicklistValuesForField.join("', '");
                const recordTypBasedFakeRecipeValue = `${this.openingRecipeSyntax} random_choice('${commaJoinedPicklistChoices}') ${this.closingRecipeSyntax}`;
    
                let recordTypeTodoVerbiage = `${this.generateTabs(5)}### TODO: -- RecordType Options -- ${recordTypeApiNameKey} -- Below is the faker recipe for the record type ${recordTypeApiNameKey} for the field ${associatedFieldApiName}`;
                recordTypeTodoVerbiage += `${newLineBreak}${this.generateTabs(5)}${recordTypBasedFakeRecipeValue}`;
                
                if ( allRecordTypeBasedPicklistOptions.trim() === '' ) {
                    // check to see if allRecordTypeBasedPicklistOptions has been given an initial value to properly handle recipe spacing
                    allRecordTypeBasedPicklistOptions = `${recordTypeTodoVerbiage}`;
                } else {
                    allRecordTypeBasedPicklistOptions += `${newLineBreak}${recordTypeTodoVerbiage}`;
                }
    
            }
            
        });

        return allRecordTypeBasedPicklistOptions;

    }

    buildRecordTypeBasedMultipicklistRecipeValue(recordTypeToPicklistFieldsToAvailablePicklistValuesMap: Record<string, Record<string, string[]>>,
                                                    associatedFieldApiName: string) {


        let allRecordTypeBasedMultiselectPicklistOptions:string = '';
        const newLineBreak = `\n`;

        Object.entries(recordTypeToPicklistFieldsToAvailablePicklistValuesMap).forEach(([recordTypeApiNameKey, recordTypeDetail]) => {

            const availableRecordTypePicklistValuesForField = recordTypeToPicklistFieldsToAvailablePicklistValuesMap[recordTypeApiNameKey][associatedFieldApiName];
            if ( availableRecordTypePicklistValuesForField ) {

                const commaJoinedPicklistChoices = availableRecordTypePicklistValuesForField.join("', '");
                const recordTypBasedFakeRecipeValue = `${this.openingRecipeSyntax} (';').join((fake.random_sample(elements=('${commaJoinedPicklistChoices}')))) ${this.closingRecipeSyntax}`;
                
                let recordTypeTodoVerbiage = `${this.generateTabs(5)}### TODO: -- RecordType Options -- ${recordTypeApiNameKey} -- Below is the Multiselect faker recipe for the record type ${recordTypeApiNameKey} for the field ${associatedFieldApiName}`;
                recordTypeTodoVerbiage += `${newLineBreak}${this.generateTabs(5)}${recordTypBasedFakeRecipeValue}`;
                
                if ( allRecordTypeBasedMultiselectPicklistOptions.trim() === '' ) {
                    // check to see if allRecordTypeBasedPicklistOptions has been given an initial value to properly handle recipe spacing
                    allRecordTypeBasedMultiselectPicklistOptions = `${recordTypeTodoVerbiage}`;
                } else {
                    allRecordTypeBasedMultiselectPicklistOptions += `${newLineBreak}${recordTypeTodoVerbiage}`;
                }
    
            }

        });

        return allRecordTypeBasedMultiselectPicklistOptions;
    }

}